"""DOCX document export service - generates Word docs on demand."""

import io
from datetime import datetime


def generate_docx(guide_dict: dict, diagram_dict: dict) -> bytes:
    """
    Generate a DOCX file from guide and diagram data.
    
    This function is called on-demand when user clicks export.
    Returns raw bytes that can be sent directly as a download.
    
    Args:
        guide_dict: Technical guide as dictionary
        diagram_dict: Mermaid diagram as dictionary
        
    Returns:
        DOCX file as bytes
    """
    # Lazy import to prevent startup issues
    from docx import Document
    from docx.shared import Inches, Pt, RGBColor
    from docx.enum.text import WD_ALIGN_PARAGRAPH
    
    doc = Document()
    
    # Title
    title = doc.add_heading(guide_dict.get('title', 'Technical Documentation'), level=0)
    title.alignment = WD_ALIGN_PARAGRAPH.CENTER
    
    # Subtitle
    subtitle_text = guide_dict.get('subtitle', '')
    if subtitle_text:
        subtitle = doc.add_paragraph(subtitle_text)
        subtitle.alignment = WD_ALIGN_PARAGRAPH.CENTER
        if subtitle.runs:
            subtitle.runs[0].italic = True
            subtitle.runs[0].font.size = Pt(14)
            subtitle.runs[0].font.color.rgb = RGBColor(100, 100, 100)
    
    doc.add_paragraph()
    
    # Executive Summary
    doc.add_heading("Executive Summary", level=1)
    doc.add_paragraph(guide_dict.get('executive_summary', ''))
    
    # Problem Statement
    doc.add_heading("Problem Statement", level=1)
    doc.add_paragraph(guide_dict.get('problem_statement', ''))
    
    # Target Audience
    doc.add_heading("Target Audience", level=1)
    doc.add_paragraph(guide_dict.get('target_audience', ''))
    
    # Key Concepts
    concepts = guide_dict.get('key_concepts', [])
    if concepts:
        doc.add_heading("Key Concepts", level=1)
        for concept in concepts:
            p = doc.add_paragraph()
            name_run = p.add_run(f"{concept.get('name', '')}: ")
            name_run.bold = True
            p.add_run(concept.get('description', ''))
            
            if concept.get('importance'):
                imp = doc.add_paragraph()
                imp.paragraph_format.left_indent = Inches(0.5)
                imp_run = imp.add_run(f"Importance: {concept.get('importance')}")
                imp_run.italic = True
                imp_run.font.size = Pt(10)
    
    # Sections
    sections = guide_dict.get('sections', [])
    for section in sections:
        doc.add_heading(section.get('title', ''), level=1)
        doc.add_paragraph(section.get('content', ''))
        
        key_points = section.get('key_points', [])
        if key_points:
            doc.add_paragraph("Key Points:")
            for point in key_points:
                doc.add_paragraph(f"• {point}")
    
    # Architecture Diagram
    doc.add_heading("Architecture Diagram", level=1)
    doc.add_paragraph(f"Type: {diagram_dict.get('diagram_type', 'flowchart')}")
    doc.add_paragraph(diagram_dict.get('description', ''))
    
    doc.add_paragraph("Mermaid Code:")
    code_para = doc.add_paragraph()
    code_run = code_para.add_run(diagram_dict.get('mermaid_code', ''))
    code_run.font.name = 'Consolas'
    code_run.font.size = Pt(9)
    
    # Technologies
    technologies = guide_dict.get('technologies', [])
    if technologies:
        doc.add_heading("Technologies", level=1)
        doc.add_paragraph(", ".join(technologies))
    
    # Use Cases
    use_cases = guide_dict.get('use_cases', [])
    if use_cases:
        doc.add_heading("Use Cases", level=1)
        for uc in use_cases:
            doc.add_paragraph(f"• {uc}")
    
    # Next Steps
    next_steps = guide_dict.get('next_steps', [])
    if next_steps:
        doc.add_heading("Next Steps", level=1)
        for i, step in enumerate(next_steps, 1):
            doc.add_paragraph(f"{i}. {step}")
    
    # Footer
    doc.add_paragraph()
    footer = doc.add_paragraph()
    footer.alignment = WD_ALIGN_PARAGRAPH.CENTER
    footer_run = footer.add_run(f"Generated by DevOpsy | {datetime.now().strftime('%Y-%m-%d %H:%M')}")
    footer_run.font.size = Pt(9)
    footer_run.font.color.rgb = RGBColor(128, 128, 128)
    
    # Save to bytes buffer
    buffer = io.BytesIO()
    doc.save(buffer)
    buffer.seek(0)
    
    return buffer.getvalue()

